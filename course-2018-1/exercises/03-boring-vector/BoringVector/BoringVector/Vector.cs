using System;

namespace BoringVector
{
    #region 1. Структура Vector

    /*
        Реализуй структуру Vector - см. комментарии внутри нее.
    */
    /// <summary>
    /// Класс Вектора (задается двумя вещественными координатами).
    /// </summary>
    internal struct Vector
    {
        /*
            Vector задается парой вещественных координат X и Y.
        */

        /// <summary>
        /// Координата x, тип double.
        /// </summary>
        public double _x { get; set; }

        /// <summary>
        /// Координата y, тип double.
        /// </summary>
        public double _y { get; set; }
        /*
            На месте заглушек добавь реализацию базовых методов вектора:
                - квадрат длины
                - сумма векторов
                - умножение на коэффициент
                - скалярное произведение
                - векторное произведение (= площадь параллелограмма)
        */

        /// <summary>
        /// Создает новый объект <see cref="Vector"/> по двум вещественным координатам.
        /// </summary>
        /// <param name="x">Вещественная координата x.</param>
        /// <param name="y">Вещественная координата x.</param>
        /// <returns>Объект <see cref="Vector"/> с заданными координатами.</returns>
        internal Vector(double x, double y)
        {
            this._x = x;
            this._y = y;
        }

        /// <summary>
        /// Возвращает квадрат длины <see cref="Vector">.
        /// </summary>
        /// <returns>Вещественное число, квадрат длины.</returns>
        public double SquareLength()
        {
            return Math.Pow(_x, 2) + Math.Pow(_y, 2);
        }

        /// <summary>
        /// Добавляет <see cref="Vector"/> к данному. Создает новый объект типа <see cref="Vector"/>.
        /// </summary>
        /// <param name="v"><see cref="Vector"/>, который добавляется к данному</param>
        /// <returns>Объект <see cref="Vector"/>, который является суммой.</returns>
        public Vector Add(Vector v)
        {
            return new Vector(_x + v._x, _y + v._y);
        }

        /// <summary>
        /// Домножает <see cref="Vector"/> на константу. Создает новый объект <see cref="Vector"/>.
        /// </summary>
        /// <param name="k">Вещественный коэффициент.</param>
        /// <returns>Объект <see cref="Vector"/>, который в k раз больше, чем изначальный.</returns>
        public Vector Scale(double k)
        {
            return new Vector(k * _x, k * _y);
        }

        /// <summary>
        /// Возвращает скалярное произведение двух векторов.
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/>, с которым считается скалярное произведение.</param>\
        /// <returns>Тип <see cref="double"/>, скалярное произведение двух векторов.</returns>
        public double DotProduct(Vector v)
        {
            return _x * v._x + _y * v._y;
        }

        /// <summary>
        /// Возвращает численное значение векторного произведения двух векторов.
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/>, с которым считается векторное произведение.</param>\
        /// <returns>Тип <see cref="double"/>, результат векторного произведения двух векторов.</returns>
        public double CrossProduct(Vector v)
        {
            return _x * v._y - _y * v._x;
        }

        /*
            Переопредели ниже метод ToString - пусть выводит (X; Y)
        */

        /// <summary>
        /// Возвращает строковое представление <see cref="Vector"/> в формате (X; Y)
        /// </summary>
        /// <returns>Тип <see cref="string"/>, строковое представление вектора.</returns>
        override public string ToString()
        {
            return "(" + _x.ToString() + "; " + _y.ToString() + ")";
        }
        #region operators

        /*
            Реализуй также следущие операторы (Vector v, u и double k):
                - v + u, v - u
                - k * v, v * k, v / k
                - +v, -v
        */

        /// <summary>
        /// Оператор сложения двух векторов. Создает новый объект типа <see cref="Vector"/>.
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/></param>
        /// <param name="u">Тип <see cref="Vector"/></param>\
        /// <returns>Тип <see cref="Vector"/>, сумма двух векторов.</returns>
        public static Vector operator +(Vector v, Vector u)
        {
            return new Vector(v._x + u._x, v._y + u._y);
        }

        /// <summary>
        /// Оператор разности двух векторов. Создает новый объект типа <see cref="Vector"/>.
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/></param>
        /// <param name="u">Тип <see cref="Vector"/></param>\
        /// <returns>Тип <see cref="Vector"/>, разность двух векторов.</returns>
        public static Vector operator -(Vector v, Vector u)
        {
            return new Vector(v._x - u._x, v._y - u._y);
        }

        /// <summary>
        /// Оператор унарного минуса. Создает новый объект типа <see cref="Vector"/>.
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/></param>\
        /// <returns>Тип <see cref="Vector"/>, вектор, обратный данному.</returns>
        public static Vector operator -(Vector v)
        {
            return new Vector(-v._x, -v._y);
        }

        /// <summary>
        /// Оператор унарного плюса. Создает новый объект типа <see cref="Vector"/> (действие аналогично копированию объекта).
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/></param>\
        /// <returns>Тип <see cref="Vector"/>, вектор, равный данному.</returns>
        public static Vector operator +(Vector v)
        {
            return new Vector(v._x, v._y);
        }

        /// <summary>
        /// Оператор домножения вектора на число. Создает новый объект типа <see cref="Vector"/>.
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/></param>
        /// <param name="k">Тип <see cref="double"/>, коэффициент</param>\
        /// <returns>Тип <see cref="Vector"/>, результат домножения вектора на число.</returns>
        public static Vector operator *(Vector v, double k)
        {
            return new Vector(v._x * k, v._y * k);
        }

        /// <summary>
        /// Оператор домножения вектора на число. Создает новый объект типа <see cref="Vector"/>.
        /// </summary>
        /// <param name="k">Тип <see cref="double"/>, коэффициент</param>
        /// <param name="v">Тип <see cref="Vector"/></param>\
        /// <returns>Тип <see cref="Vector"/>, результат домножения вектора на число.</returns>
        public static Vector operator *(double k, Vector v)
        {
            return new Vector(k * v._x, k * v._y);
        }

        /// <summary>
        /// Оператор деления вектора на число. Создает новый объект типа <see cref="Vector"/>. При нулевом коэффициенте кидает исключение <see cref="DivideByZeroException"/>. 
        /// </summary>
        /// <param name="v">Тип <see cref="Vector"/></param>
        /// <param name="k">Тип <see cref="double"/>, коэффициент</param>\
        /// <returns>Тип <see cref="Vector"/>, результат деления вектора на число.</returns>
        public static Vector operator /(Vector v, double k)
        {
            if (Math.Abs(k) < Double.Epsilon)
            {
                throw new DivideByZeroException();
            }
            return new Vector(v._x / k, v._y / k);
        }

        #endregion
    }

    #endregion

    /*
        Время отправиться в VectorExtensions.cs за новой порцией квестов, герой!
        Как закончишь, возвращайся за щедрым вознаграждением!
    */


    #region 3. Комментарии

    /*
        Прости, я соврал. К сожалению, пока ты делал(-а) вторую часть, человек, который понимал, о чем идет речь в первой части,
        успел съездить в путешествие под названием "во все тяжкие" и теперь проходит курс реабилитации. А те, кто был хотя бы примерно в теме,
        внезапно лишились рассудка.
        Тут еще из будущего сообщили, что тебе дали задачу поинтереснее, и ты наотрез отказался(-ась) сотрудничать в передаче знаний.
        Ну а вместо тебя на эту задачу взяли пушистого котика, который отказывается разбираться в коде и уж тем более его писать - говорит у него лапки.

        В такой ситуации единственно возможное решение задачи - оставить после себя комментарии. Такие, чтобы даже котику было понятно!
        В общем, впереди неприятная для многих часть - необходимо добавить комментарии ко всем введенным типам, методам и свойствам :)


        _Хозяйке на заметку_

        Для многих это действительно довольно неприятная и скучнейшая часть - писать комментарии к коду. Проблема в том,
        что это еще и не так просто как кажется на первый взгляд. Очень желательно выдерживать единый стиль, писать по существу,
        писать не "для текущего разобравшегося в проблеме и предметной области себя", а для "того парня", "себя через год". Ну или пушистого котика.

        Есть и хорошее в этом деле. Комментирование кода очень похоже на написание автотестов - оно позволяет взглянуть
        на задачу и ее решение немного с другой стороны. Например, если слова не вяжутся, и не получается написать простое и короткое
        описание к методу или типу - это хороший сигнал, что он "с душком", и его стоит переделать/отрефакторить. 
        Я лично чаще пишу комментарии ближе к концу работы над задачей. Это позволяет мне еще раз просмотреть весь написанный код под
        слегка иным углом обзора и самому сделать первичный code review.


        Ты мог(-ла) заметить, что в предыдущих заданиях для комментариев я использовал немного необычный синтаксис:
    
            /// <summary>
            /// Возвращает объект <see cref="DateTime"/> с заданными временем и значением <see cref="DateTime.Kind"/>.
            /// </summary>
            /// <param name="dt">Объект <see cref="DateTime"/>, задающий время.</param>
            /// <param name="kind">Значение <see cref="DateTime.Kind"/>, задающий соответствующее свойство возвращаемого объекта.</param>
            /// <returns>Объект <see cref="DateTime"/> с заданными временем и значением <see cref="DateTime.Kind"/>.</returns>

        Такой блок является комментарием, т.к. каждая строка начинается с //, но имеет свою внутреннюю структуру и синтаксис.
        Это так называемые Xml documentation comments. Их поддерживает сам компилятор. Они позволяют писать чуть более умные и продвинутые комментарии к сущностям,
        а потом, например, автоматически генерировать по ним красивую документацию.
        Правилом хорошего тона считается писать комментарии к методам, классам и другим сущностям, используя данный синтаксис - так ты и комментируешь их, и документируешь.
        Внутри методов он не поддерживается, поэтому там только обычные (// или /*).

        Ниже приведены примеры простейших комментариев. Если наведете мышкой на название метода DoNothing, увидишь,
        что студия отображает комментарий в подписи (в других IDE из коробки без плагинов это вряд ли будет работать).
        Если навести на аргумент метода DoNothing - something, увидишь комментарий к нему.
        Наведи теперь на NotImplementedException() - комментарий во всплывашке сделан с помощью такого же синтаксиса.
        Код .Net Framework задокументирован именно таким синтаксисом.

        Чтобы создать такой комментарий, не нужно писать разметку целиком самому. Если ввести ///, студия сама создаст нужные блоки.

        Плюсы Xml documentation comments:
            - блок комментариев имеет четкую предзаданную структуру, что дает возможность воспользоваться различными инструментариями
                автогенерации документации (и создавать, например, документацию вроде MSDN).
                В последней лабе мы, надеюсь, научимся генерировать для web api страничку с документацией к нашему апи и увидим, что генератор в том числе
                может для каждого метода апи создавать формочку для его проверки и ручного тестирования.
            - IDE может показывать ее в чуть более удобном виде, нежели если бы ты писал(-а) их обычным способом.
                Например, показывать во всплывающей подсказке только самое необходимое короткое описание, а длинное с пояснениями и примерами кода не показывать.
            - все названия типов, методов и свойств можно задавать в виде ссылки, например, <see cref=Vector.DotProduct"/>, и это
                будет строгая, проверяемая компилятором, ссылка. Ты, думаю, помнишь, что компилятор как сервис в частности предоставляет разные возможности рефакторинга,
                например, переименование. Так вот, если воспользоваться им и переименовать метод DotProduct у структуры Vector, то
                переименуется и текст в ссылке. Если же ссылка указывает на невалидную сущность, то студия явно даст понять: "Cannot resolve symbol 'blah-blah-blah'".
                Я лично не проверял, но по идее можно даже сделать так, чтобы в таком случае была ошибка компиляции. В генерируемой же документации эти ссылки будут
                заменены на реальные ссылки на страницы описания соответствующей сущности, что довольно удобно для навигации по ней.

    */

    /// <summary>
    /// Класс, не делающий ничего.
    /// </summary>
    internal class Foo
    {
        /// <summary>
        /// Не делает ничего, как и подобает методам данного класса.
        /// </summary>
        /// <param name="something">Экземпляр <see cref="object"/> чего бы то ни было.</param>
        public static void DoNothing(object something)
        {
            // nothing to do here
        }

        public static void ThrowNotImplementedException()
        {
            throw new NotImplementedException();
        }
    }

    #endregion


    #region 4. Тесты

    /*
        Прости еще раз, но на этом твои мучения еще не кончаются. Проблема в том, что у котика все еще лапки, поэтому очень важно
        покрыть тестами хотя бы базовые методы структуры Vector:
            SquareLength
            Add
            Scale
            DotProduct
            CrossProduct

        Для этого создай в этом же солюшене (если ты не в студии, то можешь и не в солюшене) проект BoringVector.Tests,
        который будет содержать класс с набором тестов. Используй Xunit (в принципе можешь воспользоваться и другим фреймворком для тестирования).

        Особо не заморачивайся с тем, чтобы оттестировать все возможные специальные случаи - в данном задании важно, чтобы
        ты просто разобрался(-ась), как писать автотесты и как их запускать. Это задание НЕ на то, как писать хорошие тесты.

        Примечание: структура Vector описана как internal структура, поэтому по умолчанию сборке BoringVector.Tests она не видна.
        Чтобы она была видна, существует специальная директива компилятору:
            [assembly: InternalsVisibleTo("XXX")]
        , где XXX - название проекта, которому ты хочешь сделать видимыми свои internal'ы.

        Можешь посмотреть, в задании [01-primitive-types] эта директива есть в файле Program.cs проекта Numbers.

        Итак, создай проект с тестами и добейся того, чтобы базовые методы структуры Vector их проходили.
    */

    #endregion


    /*
        На этом все. Время делать пулл реквест и наслаждаться заслуженным отдыхом :)
    */
}
